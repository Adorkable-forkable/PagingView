{"name":"Pagingview","tagline":"Infinite paging, Smart auto layout, Interface of similar to UIKit.","body":"# PagingView\r\n\r\n[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)\r\n[![Version](https://img.shields.io/cocoapods/v/PagingView.svg?style=flat)](http://cocoadocs.org/docsets/PagingView)\r\n[![License](https://img.shields.io/cocoapods/l/PagingView.svg?style=flat)](http://cocoadocs.org/docsets/PagingView)\r\n[![Platform](https://img.shields.io/cocoapods/p/PagingView.svg?style=flat)](http://cocoadocs.org/docsets/PagingView)\r\n\r\nInfinite paging, Smart auto layout, Interface of similar to UIKit.\r\n\r\n#### [Appetize's Demo](https://appetize.io/app/030jqrt4nkm60rc0qu1wrvg4v8)\r\n\r\n## How to Install PagingView\r\n\r\n### iOS 8+\r\n\r\n#### Cocoapods\r\n\r\nAdd the following to your `Podfile`:\r\n\r\n```Ruby\r\nuse_frameworks!\r\npod \"PagingView\"\r\n```\r\nNote: the `use_frameworks!` is required for pods made in Swift.\r\n\r\n#### Carthage\r\n\r\nAdd the following to your `Cartfile`:\r\n\r\n```Ruby\r\ngithub \"KyoheiG3/PagingView\"\r\n```\r\n\r\n### iOS 7\r\n\r\nJust add everything in the `PagingView.swift`, `PagingViewCell.swift` and `Constraints.swift` file to your project.\r\n\r\n## Usage\r\n\r\n### import\r\n\r\nIf target is ios8.0 or later, please import the `PagingView`.\r\n\r\n```swift\r\nimport PagingView\r\n```\r\n\r\n### PagingView Variable\r\n\r\n```swift\r\nweak var dataSource: PagingViewDataSource?\r\n```\r\n* DataSource of `PagingView`. Same as `dataSource` of `UICollectionView`.\r\n\r\n```swift\r\nvar pagingMargin: UInt\r\n```\r\n* Margin between the content.\r\n* Default is `0`.\r\n\r\n```swift\r\nvar pagingInset: UInt\r\n```\r\n* Inset of content relative to size of `PagingView`.\r\n* Value of two times than of `pagingInset` to set for the left and right of `contentInset`.\r\n* Default is `0`.\r\n\r\n### PagingView Function\r\n\r\n```swift\r\nfunc dequeueReusableCellWithReuseIdentifier(identifier: String) -> PagingView.PagingViewCell\r\n```\r\n* Used by the `delegate` to acquire an already allocated cell, in lieu of allocating a new one.\r\n\r\n```swift\r\nfunc registerNib(nib: UINib?, forCellWithReuseIdentifier identifier: String)\r\n```\r\n* If a nib is registered, it must contain exactly 1 top level object which is a `PagingViewCell`.\r\n\r\n```swift\r\nfunc registerClass<T : PagingView.PagingViewCell>(viewClass: T.Type, forCellWithReuseIdentifier identifier: String)\r\n```\r\n* If a class is registered, it will be instantiated via `init(frame: CGRect)`.\r\n\r\n```swift\r\nfunc reloadData()\r\n```\r\n* Requery the `dataSource` and `delegate` as necessary.\r\n\r\n```swift\r\nfunc numberOfSections() -> Int\r\nfunc numberOfItemsInSection(section: Int) -> Int\r\n```\r\n* Information about the current state of the `PagingView`.\r\n\r\n```swift\r\nfunc scrollToPosition(position: PagingView.PagingView.Position, indexPath: NSIndexPath? = default, animated: Bool = default)\r\n```\r\n* To scroll at `Position`.\r\n* Cell configure is performed at `NSIndexPath`.\r\n\r\n```swift\r\nfunc configureAtPosition(position: PagingView.PagingView.Position, toIndexPath: NSIndexPath? = default)\r\n```\r\n* Configure cell of `Position`.\r\n* IndexPath of cell in the center if indexPath is `nil`.\r\n\r\n### PagingViewDataSource Function\r\n\r\n```swift\r\nfunc pagingView(pagingView: PagingView.PagingView, numberOfItemsInSection section: Int) -> Int\r\n```\r\n* Paging count number of paging item in section.\r\n\r\n```swift\r\nfunc pagingView(pagingView: PagingView.PagingView, cellForItemAtIndexPath indexPath: NSIndexPath) -> PagingView.PagingViewCell\r\n```\r\n* Implementers should *always* try to reuse cells by setting each cell's reuseIdentifier and querying for available reusable cells with `dequeueReusableCellWithReuseIdentifier:`.\r\n\r\n```swift\r\noptional func numberOfSectionsInPagingView(pagingView: PagingView.PagingView) -> Int\r\n```\r\n* Paging count number of paging item section in `PagingView`.\r\n* Default return value is `1`.\r\n\r\n```swift\r\noptional func indexPathOfStartingInPagingView(pagingView: PagingView.PagingView) -> NSIndexPath?\r\n```\r\n* IndexPath when `pagingView:cellForItemAtIndexPath:` is first called\r\n* Default return value is `0 - 0` of `NSIndexPath` instance.\r\n\r\n### PagingViewDelegate Function\r\n\r\n```swift\r\noptional func pagingView(pagingView: PagingView.PagingView, willDisplayCell cell: PagingView.PagingViewCell, forItemAtIndexPath indexPath: NSIndexPath)\r\noptional func pagingView(pagingView: PagingView.PagingView, didEndDisplayingCell cell: PagingView.PagingViewCell, forItemAtIndexPath indexPath: NSIndexPath)\r\n```\r\n* Called at the display and end-display of.\r\n\r\n### PagingViewCell Function\r\n\r\n```swift\r\nfunc prepareForReuse()\r\n```\r\n* if the cell is reusable (has a reuse identifier), this is called just before the cell is returned from the paging view method `dequeueReusableCellWithReuseIdentifier:`.\r\n\r\n## LICENSE\r\n\r\nUnder the MIT license. See LICENSE file for details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}